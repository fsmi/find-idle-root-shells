#!/usr/bin/perl
#
# Depends on libsys-utmp-perl
#
# Looks for open shells, owned by root, with valid (pseudo)ttys attached and
# checks whether they've been idle for too long.
#
# Copyright (C) 2007 Fabian Knittel <fabian.knittel@fsmi.uni-karlsruhe.de>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

use strict;
use warnings;
use Sys::Utmp;
use Sys::Syslog;
use POSIX qw(strftime uname);
use Proc::ProcessTable;

use vars qw($TIME_FMT %UTMP @TTYDRIVERS @SHELLS $VAR_DIR $CMD $since_last_run
            $PROC_DIR);
$TIME_FMT = "%Y-%m-%d %H:%M:%S";
$VAR_DIR = "/var/run";
$CMD = "find-idle-root-shells";
$PROC_DIR = "/proc";

use vars qw($FORCED_NO_ADMIN $ALL_USERS $DRY_RUN $DEBUG $LOG_TO_CONSOLE);
$DEBUG = 0;
$DRY_RUN = 0;
$ALL_USERS = 0;
$FORCED_NO_ADMIN = 0;
$LOG_TO_CONSOLE = 0;

sub get_processes_hash();
sub get_env_of_process($);
sub get_tty_of_process($);
sub get_groups_of_user($);
sub is_valid_shell($);
sub load_shells();
sub load_tty();
sub load_utmp();
sub dp($);
sub within_time($$);

if ($DEBUG) {
	openlog($CMD, "pid,ndelay", "user");
}

my $cron_mode = 0;
if ($#ARGV >= 0) {
	if ($ARGV[0] eq '--cron-mode') {
		$cron_mode = 1;
	} else {
		die "Usage: $CMD [--cron-mode]\n".
		    "  --cron-mode  Throttle notification messages.\n";
	}
}

load_utmp();
load_tty();
load_shells();

my $cur_time = time();
my $last_run;

if ($cron_mode) {
	my $last_run_file = $VAR_DIR."/".$CMD.".last-run";
	if (-e $last_run_file) {
		open(LR, $last_run_file) or
			die("$CMD: reading $last_run_file: $!\n");
		$last_run = <LR>;
		chomp $last_run;
		close(LR);
	}
	else
	{
		$last_run = $cur_time;
	}

	open(LR, ">".$last_run_file) or
		die("$CMD: writing $last_run_file: $!\n");
	print LR $cur_time;
	close(LR) or
		die("$CMD: writing $last_run_file: $!\n");

	$since_last_run = $cur_time - $last_run;
}

my $pid_hash = get_processes_hash();
foreach my $pid (keys %{$pid_hash}) {
	my $process = ${$pid_hash}{$pid};

	#
	# Gather further information.
	#

	my $ppath = $PROC_DIR.'/'.$process->pid;

	my $exe;
	next unless defined($exe = readlink("$ppath/exe"));

	# Skip non-root processes.
	next unless ($process->uid == 0 || $ALL_USERS);

	# Skip non-shells.
	next unless is_valid_shell($exe);

	# Only processes with a valid tty are interesting.
	next unless ($process->ttydev ne '');

	my $env;
	next unless ($env = get_env_of_process($process->pid));

	my $last_mod;
	next unless defined ($last_mod = (stat($process->ttydev))[9]);

	# Calculate idle time.
	my $idle_time = $cur_time - $last_mod;

	my $who;
	my $login_time;
	my $from;


	# Search for matching line device...
	my $from_x = 0;
	my $ld;
	$process->ttydev =~ /^\/dev\/(.*)/;
	my $short_dev = $1;
	if (defined($UTMP{$short_dev})) {
		$ld = $short_dev;
	} else {
		if (${$env}{'DISPLAY'} &&
		    ${$env}{'DISPLAY'} =~ /(.*:[0-9]+)(\.[0-9]+)?/)
		{
			my $short_disp = $1;
			if (defined($UTMP{$short_disp})) {
				$ld = $short_disp;
				$from_x = 1;
			}
		}
	}
	if (defined($ld)) {
		$who = ${$UTMP{$ld}}{'user'};
		$login_time = ${$UTMP{$ld}}{'time'};
		$from = ${$UTMP{$ld}}{'host'};
	}

	my $groups;
	if (defined($who) && ($who ne 'root')) {
		$groups = get_groups_of_user($who);
	}

	my $is_user = 0;
	if ($groups) {
		if (!${$groups}{'adm'}) {
			$is_user = 1;
		}
	}

	#
	# Decide what to do.
	#

	# Defaults
	my $send_warning = 0;
	my $might_kill = 0;
	my $do_kill = 0;

	# Normal user or admin?
	if ($is_user || $FORCED_NO_ADMIN) {
		dp $process->pid." is normal user. idle $idle_time.\n";

		# Warn after 10 minutes idle time.
		if ($idle_time > (10 * 60)) {
			$send_warning = 1;
			$might_kill = 1;
		}

		# Kill after 30 minutes idle time.
		if ($idle_time > (30 * 60)) {
			$do_kill = 1;
		}
	}
	else
	{
		dp $process->pid." is admin. idle $idle_time.\n";

		if ($cron_mode) {
			# 1st warning after 15 minutes inactivity.
			if (within_time($idle_time, 15 * 60)) {
				$send_warning = 1;
				dp $process->pid.": 15 min inactivity\n";

			# 2nd warning after 30 minutes inactivity.
			} elsif (within_time($idle_time, 30 * 60)) {
				$send_warning = 1;
				dp $process->pid.": 30 min inactivity\n";

			# Continous warnings after every 60 minutes of
			# inactivity.
			} elsif ($idle_time >= (60 * 60)) {
				my $t = ($idle_time % (60 * 60));
				dp $process->pid.": >=60 min inactivity ($t)\n";
				if (within_time($t, 0)) {
					$send_warning = 1;
					dp $process->pid.": warning >=60 min ".
					   "inactivity\n";
				}
			}
		} else {
			# Warnings after 15 minutes inactivity.
			if ($idle_time >= (15 * 60)) {
				$send_warning = 1;
				dp $process->pid.": >= 15 min inactivity\n";
			}
		}
	}


	#
	# Do it.
	#

	if ($send_warning) {
		my $s;

		$s = "$exe (".$process->pid.") ";
		if ($from_x) {
			$s .= "(X11) ";
		}
		if ($who) {
			$s .= "$who ";
		}
		$s .= "on ".(uname())[1]." ";
		if ($from) {
			$s .= "from $from";
		}
		$s .= "\n".
		      "  Idle since ".strftime($TIME_FMT, localtime($last_mod)).
		      " (${idle_time}s)\n";
		if ($might_kill) {
			$s .= "  To be killed!\n";
		}
		if ($login_time) {
			$s .= "  Login at ".
			      strftime($TIME_FMT, localtime($login_time))."\n";
		}
		$s .= "  Dev $short_dev\n";

		print $s;
	}
	if ($do_kill) {
		if ($DRY_RUN) {
			print "WOULD have sent SIGUP to ".$process->pid.".\n";
		} else {
			if (kill(1, $process->pid) == 1) {
				print "Sent SIGHUP to ".$process->pid.".\n";
			} else {
				print "Failed to send SIGHUP to ".
				      $process->pid.".\n";
			}
		}
	}
}

sub load_utmp()
{
	my $utmp = Sys::Utmp->new();
	while (my $utent =  $utmp->getutent())
	{
		if ($utent->user_process &&
		    !defined($UTMP{$utent->ut_line()}))
		{
			my $l = $utent->ut_line();

			${$UTMP{$l}}{'user'} = $utent->ut_user;
			${$UTMP{$l}}{'time'} = $utent->ut_time;
			${$UTMP{$l}}{'host'} = $utent->ut_host;
		}
	}
	$utmp->endutent;
}

sub load_tty()
{
	open(D, "/proc/tty/drivers") or die "/proc/tty/drivers: $!\n";
	while (my $d = <D>) {
		if ($d =~ /^[-a-zA-Z0-9\/_]+[ \t]+([-a-zA-Z0-9\/_]+)[ \t]+.*$/)
		{
			push @TTYDRIVERS, $1;
		}
	}
	close(D);
}

sub load_shells()
{
	open(S, "/etc/shells") or die "/etc/shells: $!\n";
	@SHELLS = <S>;
	close(S);
	chomp(@SHELLS);
}

sub is_valid_shell($)
{
	my $exe = $_[0];
	return (grep({ $_ eq $exe } @SHELLS));
}

sub get_env_of_process($)
{
	my $pid = $_[0];
	my %ENV;

	open(E, "/proc/$pid/environ") or return;
	my $l = <E>;
	close(E);

	if (defined($l)) {
		my @ENV_LIST = split(/\0/, $l);
		foreach my $e (@ENV_LIST) {
			$e =~ /^(.*?)=(.*)$/;
			$ENV{$1} = $2;
		}
	}
	return \%ENV;
}

sub get_groups_of_user($)
{
	my $user = $_[0];
	my %GROUPS;

	setgrent();
	while (my @GE = getgrent())
	{
		my $group = $GE[0];
		my @MEMBERS = split(/ /, $GE[3]);

		if (grep({ $_ eq $user } @MEMBERS)) {
			$GROUPS{$group} = 1;
		}
	}
	endgrent();

	return \%GROUPS;
}

sub dp($)
{
	if ($DEBUG) {
		if ($LOG_TO_CONSOLE) {
			print STDERR $_[0];
		}

		foreach my $m (split /\n/, $_[0]) {
			next if ($m eq '');
			syslog("debug", $m);
		}
	}
}

sub get_processes_hash()
{
	my %PID_HASH;
	my $process_table = new Proc::ProcessTable;
	foreach my $process (@{$process_table->table}) {
		$PID_HASH{$process->pid} = $process;
	}
	return \%PID_HASH;
}

sub within_time($$)
{
	my $idle_secs = $_[0];
	my $expected_secs = $_[1];

	return ($idle_secs >= $expected_secs &&
	        $since_last_run > $idle_secs - $expected_secs);
}
